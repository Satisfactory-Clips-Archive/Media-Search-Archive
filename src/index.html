<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Q&A Clips Archive Search</title>
<style>
*
{
	box-sizing: border-box ;
	margin: 0 ;
	padding: 0 ;
	font: inherit ;
	color: inherit ;
	font-size: 1em ;
}

ol, ul
{
	list-style: inside none ;
}

.results > ol
{
	padding: .5em ;
}

.results > ol > li
{
	padding: 1em ;
	margin: .5em ;
	border: 1px solid #000 ;
}

h1,
h2,
h3
{
	font-weight: bolder ;
	margin-top: .25em ;
}

h1
{
	font-size: 2em ;
}
h2
{
	font-size: 1.6em ;
}
h3
{
	font-size: 1.2em ;
}

aside
{
	white-space: pre-wrap ;
	font-family: monospace ;
}

legend[tabindex]
{
	cursor: pointer ;
}

fieldset:not(:focus-within) > legend ~ *
{
	display: none ;
}
</style>
<script src="./lunr.min.js"></script>
<script src="./lunr-highlighter.js"></script>
<link rel="preload" as="fetch" crossorigin="anonymous" href="./lunr.json">
<link rel="preload" as="fetch" crossorigin="anonymous" href="./docs.json">
<link rel="preload" as="fetch" crossorigin="anonymous" href="./synonyms.json">
<template id="loading">
	<section>
		<header>Loading</header>
		<section>
			<p>Please be patient while the application loads.</p>
		</section>
	</section>
</template>
<template id="ready">
	<section>
		<header>
			<h1>Q&A Clips Archive Search <output for="search"></h1>
		</header>
		<section>
			<form>
				<input type="search" id="search" required name="q">
				<button type="submit" title="Search">ðŸ”Ž</button>
				<fieldset>
					<legend tabindex="0">Search Settings</legend>
				<fieldset>
					<legend tabindex="0">Dates</legend>
					<ul>
						<li>
							<label for="date-from">Date From</label>
							<input id="date-from" name="df" type="date" min="2020-09-01" step="7">
						</li>
						<li>
							<label for="date-to">Date To</label>
							<input id="date-to" name="dt" type="date" min="2020-09-01" step="7">
						</li>
					</ul>
				</fieldset>
				<fieldset>
					<legend tabindex="0">Advanced</legend>
					<p>Advanced settings for the client-side search.</p>
					<ul>
						<li>
							<label
								for="min-score"
								title="Minimum Search Score"
							>min. score</label>
							<input
								id="min-score"
								name="ms"
								inputmode="numeric"
								pattern="[0-9]+\.[0-9]+"
								value="0.0"
							>
						</li>
					</ul>
				</fieldset>
				</fieldset>
			</form>
		</section>
		<section class="results">
		</section>
	</section>
</template>
<template id="document-result">
	<li>
		<section>
			<h1></h1>
			<h2></h2>
			<div></div>
			<h3>Topics</h3>
			<ul></ul>
			<h3>Transcript</h3>
			<aside></aside>
		</section>
		<!--
		<button class="copy" type="button">Copy to Clipboard</button>
		-->
	</li>
</template>
</head>
<body>
<section id="not-ready">
	<header>
		<h1>JavaScript Required</h1>
	</header>
	<section>
		<p>JavaScript is required for this application to function.</p>
		<p>If you can still see this notice,
			then the application is either not ready,
			or your browser is not supported.</p>
	</section>
</section>
<script async defer>
(async () => {
	if ( ! (URLSearchParams)) {
		throw new Error('Unsupported');
	}

	const not_ready = document.getElementById('not-ready');
	const loading = document.getElementById('loading').content.cloneNode(
		true
	);
	const ready = document.getElementById('ready').content.cloneNode(
		true
	);
	const search_result_template = document.getElementById(
		'document-result'
	).content;

	not_ready.parentNode.replaceChild(loading, not_ready);

	const fetch_prebuilt_index = fetch('./lunr.json');
	const fetch_docs = fetch('./docs.json');
	const fetch_synonyms = fetch('./synonyms.json');

	const [
		prebuilt_index,
		docs,
		synonyms,
	] = await Promise.all((await Promise.all([
		fetch_prebuilt_index,
		fetch_docs,
		fetch_synonyms,
	])).map((e) => e.json()));

	const synonym_keys = Object.keys(synonyms);

	lunr.Pipeline.registerFunction(
		(token) => {
			const lowercase = token.toString().toLowerCase();

			if (synonym_keys.includes(synonyms)) {
				return token.update(() => {
					return synonyms[lowercase];
				});
			}

			return token;
		},
		'aliasSatisfactoryVocabulary'
	);

	const index = lunr.Index.load(prebuilt_index);

	const form = ready.querySelector('form');
	const searchbar = ready.querySelector('input[type="search"]');
	const results_container = ready.querySelector('.results');
	const result_count = ready.querySelector('header output[for="search"]');

	const maybe_date_max = [0, 20200901];

	for (const doc_entry of Object.entries(docs)) {
		const [, doc] = doc_entry;
		const maybe = parseInt(doc.date.replace(/\-/g, ''), 10);

		if ( ! maybe_date_max.includes(maybe)) {
			maybe_date_max.push(maybe);
		}
	}

	const date_max_parts = /^(\d+)(\d{2})(\d{2})$/.exec(Math.max(...maybe_date_max).toString(10));
	const date_max = `${
			date_max_parts[1]
		}-${
			date_max_parts[2]
		}-${
			date_max_parts[3]
		}`;

	const date_from = form.querySelector('#date-from');
	const date_to = form.querySelector('#date-to');
	const score_filter = form.querySelector('#min-score');

	const ordinals = [
		'th',
		'st',
		'nd',
		'rd',
		'th',
		'th',
		'th',
		'th',
		'th',
		'th',
	];

	date_from.max = date_to.max = date_max;
	date_from.value = '2020-09-01';
	date_to.value = date_to.max;

	let timeout;
	let last_query = '';

	function search (query) {
		return index.search(query).map((result) => {
			return [docs[result.ref], result];
		});
	};

	function perform_search (modify_state = true) {
		results_container.textContent = '';

		cancelAnimationFrame(timeout);

		timeout = requestAnimationFrame(() => {
			const query = searchbar.value;
			const title = `Q&A Clips Archive Search - ${query}`;

			last_query = query;

			const formdata = new FormData(form);
			const filter_date_from = parseInt(
				formdata.get('df').replace(/\-/g, ''),
				10
			);
			const filter_date_to = parseInt(
				formdata.get('dt').replace(/\-/g, ''),
				10
			);
			const filter_min_score = parseFloat(formdata.get('ms'));

			document.head.querySelector('title').textContent = title;
			if (modify_state) {
			history.pushState(
				{},
				title,
				`?q=${
					encodeURIComponent(last_query)
				}&df=${
					encodeURIComponent(formdata.get('df'))
				}&dt=${
					encodeURIComponent(formdata.get('dt'))
				}&ms=${
					encodeURIComponent(formdata.get('ms'))
				}`
			);
			}

			const docs_results = search(query.split(' ').map((e) => {
				return e.replace(/\.+$/, '');
			}).join(' ')).filter((e) => {
				const [doc, result] = e;
				const dateint = parseInt(doc.date.replace(/\-/g, ''), 10);

				return (
					dateint >= filter_date_from
					&& dateint <= filter_date_to
					&& result.score >= filter_min_score
				);
			});

			result_count.textContent = '(' + docs_results.length + ' results found)';

			if (docs_results.length > 0) {
				const frag = document.createElement('ol');

				docs_results.map((e) => {
					const [doc, result] = e;
					const node = search_result_template.cloneNode(true);
					const doc_date = new Date(doc.date);

					node.querySelector('h1').textContent =
						doc_date.getDate() +
						ordinals[doc_date.getDate() % 10] +
						' ' +
						doc_date.toLocaleDateString(
						'en-GB',
							{ year: 'numeric', month: 'long'}
						) + ' Livestream';
					node.querySelector('h2').textContent = doc.title;

					if (doc.urls.length > 1) {
						var urls_dest = document.createElement('ol');

						doc.urls.map((url, i) => {
							const anchor = document.createElement('a');
							const part = document.createElement('li');

							anchor.rel = 'noopener';
							anchor.target = '_blank';
							anchor.textContent = url;
							anchor.href = url;

							part.textContent = `Part ${i + 1}`;
							part.appendChild(anchor);

							return part;
						}).forEach((subnode) => {
							urls_dest.appendChild(subnode);
						});
					} else {
						var urls_dest = document.createElement('p');
						const anchor = document.createElement('a');

						anchor.rel = 'noopener';
						anchor.target = '_blank';
						anchor.textContent = doc.urls[0];
						anchor.href = doc.urls[0];

						urls_dest.appendChild(anchor);
					}

					doc.topics.map((topic) => {
						const subnode = document.createElement('li');
						const anchor = document.createElement('a');

						anchor.rel = 'noopener';
						anchor.target = 'blank';
						anchor.textContent = topic;
						anchor.href = `https://github.com/SignpostMarv/twitch-clip-notes/blob/main/coffeestainstudiosdevs/satisfactory/topics/${topic}.md`;

						subnode.appendChild(anchor);

						return subnode
					}).forEach((subnode) => {
						node.querySelector('ul').appendChild(subnode);
					});


					node.querySelector('section').replaceChild(urls_dest, node.querySelector('div'));

					const transcription = node.querySelector('aside');
					transcription.textContent = doc.transcription;

					const positions = [];

					Object.keys(result.matchData.metadata).forEach((term) => {
						positions.push(...(
								result.matchData.metadata[term].transcription
								|| {position:[]}
							).position
						);
					});
					lunrhighlighter(
						transcription,
						positions
					);

					return node;
				}).forEach((node) => {
					frag.appendChild(node);
				});

				results_container.appendChild(frag);
			}
		});
	};

	/*
	searchbar.addEventListener('keyup', perform_search);
	searchbar.addEventListener('blur', perform_search);
	searchbar.addEventListener('change', perform_search);
	*/
	form.addEventListener('submit', (e) => {
		e.preventDefault();
		if (searchbar.checkValidity()) {
			perform_search();
		}
	});

	function hashsearch(modify_state = true) {
		const params = new URLSearchParams(location.search);

		if (params.has('q')) {
			searchbar.value = params.get('q');

			if (params.has('df')) {
				date_from.value = params.get('df');
			} else {
				date_from.value = date_from.min;
			}

			if (params.has('dt')) {
				date_to.value = params.get('dt');
			} else {
				date_to.value = date_to.max;
			}

			if (params.has('ms')) {
				score_filter.value = params.get('ms');
			} else {
				score_filter.value = '0.0';
			}

			perform_search(modify_state);
		}
	}

	window.onpopstate = () => {
		hashsearch(false);
	};
	hashsearch();

	document.body.firstElementChild.parentNode.replaceChild(
		ready,
		document.body.firstElementChild
	);

	/**
	document.body.addEventListener(
		'click',
		(e) => {
			console.log('foo');
			if ((e.target instanceof HTMLButtonElement) && e.target.classList.contains('copy')) {
				navigator.clipboard.writeText(e.target.parentNode.querySelector('section').textContent);
			}
		},
		{
			capture: true,
			passive: true,
		}
	);
	*/
})();
</script>
</body>
</html>
